///
/// SymbolicMath toolkit
/// (c) 2017-2020 by Daniel Schwen
///

#include "SMFunctionLibJIT.h"
#include <stdio.h>

#include <jit/jit-dump.h>

namespace SymbolicMath
{

Function::~Function()
{
  // destroy context only at function end of life
  if (_jit_context)
    jit_context_destroy(_jit_context);
}

void
Function::compile()
{
  if (_jit_code)
    return;

  // build and lock context
  _jit_context = jit_context_create();
  jit_context_build_start(_jit_context);

  // build function objext (takes no parameters, returns a double)
  jit_type_t signature = jit_type_create_signature(jit_abi_cdecl, jit_type_float64, nullptr, 0, 1);
  jit_function_t function = jit_function_create(_jit_context, signature);
  jit_type_free(signature);

  // return the value generated by the expression tree
  jit_insn_return(function, _root.jit(function));

  // compile, unlock context, transform into closure (jit_function_apply does NOT work!)
  jit_function_compile(function);
  jit_context_build_end(_jit_context);
  _jit_code = reinterpret_cast<JITFunctionPtr>(jit_function_to_closure(function));
}

} // namespace SymbolicMath
