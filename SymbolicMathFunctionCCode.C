#include "SymbolicMathFunctionCCode.h"
#include <stdio.h>

namespace SymbolicMath
{

Function::~Function()
{
  // destroy context only at function end of life
  // if (_jit_context)
  //   jit_context_destroy(_jit_context);
}

void
Function::compile()
{
  if (_jit_closure)
    return;

  // build and lock context
  std::string ccode = "#include <cmath>\ndouble F()\n{\n  return ";

  // return the value generated by the expression tree
  bool dummy;
  ccode += _root.jit(dummy) + ";\n}";

  // compile, unlock context, transform into closure (jit_function_apply does NOT work!)
  std::cout << ccode << '\n';

  // _jit_closure = reinterpret_cast<JITFunctionPtr>(jit_function_to_closure(function));
}

Real
Function::value()
{
  // if (_jit_closure)
  //   // if a JIT compiled version exists evaluate it
  //   return _jit_closure();
  // else
  // otherwise recursively walk the expression tree (slow)
  return _root.value();
}

// end namespace SymbolicMath
}
