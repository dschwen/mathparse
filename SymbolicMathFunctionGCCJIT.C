#include "SymbolicMathFunctionGCCJIT.h"
#include <stdio.h>

namespace SymbolicMath
{

Function::~Function()
{
  // destroy context only at function end of life
  if (_jit_context)
  {
    gcc_jit_context_release(_jit_context);
    gcc_jit_result_release(_jit_result);
  }
}

void
Function::compile()
{
  if (_jit_closure)
    return;

  // build and lock context
  _jit_context = gcc_jit_context_acquire();

  // for debugging
  // gcc_jit_context_set_bool_option(_jit_context, GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 1);

  // turn optimizations to max
  gcc_jit_context_set_int_option(_jit_context, GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);

  // build function objext (takes no parameters, returns a double)
  gcc_jit_type * double_type = gcc_jit_context_get_type(_jit_context, GCC_JIT_TYPE_DOUBLE);
  gcc_jit_function * func = gcc_jit_context_new_function(
      _jit_context, NULL, GCC_JIT_FUNCTION_EXPORTED, double_type, "F", 0, nullptr, 0);

  // return the value generated by the expression tree
  gcc_jit_block * block = gcc_jit_function_new_block(func, nullptr);
  gcc_jit_block_end_with_return(block, nullptr, _root.jit(_jit_context));

  // compile, unlock context, transform into closure (jit_function_apply does NOT work!)
  _jit_result = gcc_jit_context_compile(_jit_context);

  _jit_closure = reinterpret_cast<JITFunctionPtr>(gcc_jit_result_get_code(_jit_result, "F"));
}

Real
Function::value()
{
  if (_jit_closure)
    // if a JIT compiled version exists evaluate it
    return _jit_closure();
  else
    // otherwise recursively walk the expression tree (slow)
    return _root.value();
}

// end namespace SymbolicMath
}
