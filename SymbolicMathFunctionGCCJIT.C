#include "SymbolicMathFunctionGCCJIT.h"
#include <stdio.h>

namespace SymbolicMath
{

Function::~Function()
{
  // destroy context only at function end of life
  if (_state.ctxt)
  {
    gcc_jit_context_release(_state.ctxt);
    gcc_jit_result_release(_jit_result);
  }
}

void
Function::compile()
{
  if (_jit_code)
    return;

  // build and lock context
  _state.ctxt = gcc_jit_context_acquire();

  // for debugging
  // gcc_jit_context_set_bool_option(_state.ctxt, GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE, 1);

  // turn optimizations to max
  gcc_jit_context_set_int_option(_state.ctxt, GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);

  // build function objext (takes no parameters, returns a double)
  gcc_jit_type * double_type = gcc_jit_context_get_type(_state.ctxt, GCC_JIT_TYPE_DOUBLE);
  _state.func = gcc_jit_context_new_function(
      _state.ctxt, NULL, GCC_JIT_FUNCTION_EXPORTED, double_type, "F", 0, nullptr, 0);

  // return the value generated by the expression tree
  _state.block = gcc_jit_function_new_block(_state.func, "F()");
  auto ret = _root.jit(_state);
  gcc_jit_block_end_with_return(_state.block, nullptr, ret);

  // compile, unlock context, transform into closure (jit_function_apply does NOT work!)
  _jit_result = gcc_jit_context_compile(_state.ctxt);

  _jit_code = reinterpret_cast<JITFunctionPtr>(gcc_jit_result_get_code(_jit_result, "F"));
}

// end namespace SymbolicMath
}
